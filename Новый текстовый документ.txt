
        Pattern pMoreDetails = Pattern.compile("<a(.+?)</a>");
        Pattern pQuotes = Pattern.compile("&quot;"); // Найти кавычки
        Pattern pNewLine = Pattern.compile("(<br>|</br>)"); // Это заменить на /n
        Pattern pImage = Pattern.compile("<img\\s*src=(.+?)>"); // Это картинка (gif) установить в ImageView
        Pattern pDelete = Pattern.compile("<ul>|</ul>|<div\\s+.+?>|</div>|<ol>|</ol>|<p>|</p>|<i>|</i>"); // Это удалить


        Pattern pGoTo = Pattern.compile("<a(.+?[^;])</a>"); // Это на поиск ссылок на статьи (concat с основным текстом)
        Pattern pBoldText = Pattern.compile("<h\\d>(.+?)</h\\d>"); // Это заменить на жирный текст
        Pattern pNewLineAndDash = Pattern.compile("<li>(.+?)</li>"); // Это заменить перенос и дефис добавить
        Pattern pStrikeText = Pattern.compile("<del>(.+?)</del>"); // Это перечеркнутый текст
        Pattern pBackgroundColor = Pattern.compile("<blockquote>(.+?)</blockquote>"); // Это нужно перекрасить (цитата)



        String subDescription = deleteAll(description, pDelete);
        subDescription = setQuotes(subDescription,pQuotes);
        subDescription = setNewLine(subDescription,pNewLine);
        subDescription = deleteImages(subDescription, pImage);
        subDescription = setDash(subDescription, pNewLineAndDash);


        CharSequence mChar = setClickableSubStrings(subDescription,pGoTo,color);
        mChar = deleteDetails(mChar, pMoreDetails);


        SpannableString ss = setUnderlineText(mChar, pBackgroundColor);
        ss = setStrikeText(ss,pStrikeText);
        ss = setBoldStyle(ss,pBoldText);
        return ss;

    }

    private CharSequence deleteDetails (CharSequence mChar, Pattern pattern) {
        Matcher matcher = pattern.matcher(mChar);
        return (matcher.find()) ? matcher.replaceFirst("") : mChar;
    }

    private CharSequence setClickableSubStrings (@NonNull String description, @NonNull Pattern pattern, @ColorInt int color) {
        String mDesc = description;
        String[] parts = description.split(pattern.toString());
        SpannableString[] mDescriptions = new SpannableString[parts.length];
        int i = 0;
        for(String part : parts) {
            Matcher matcher = pattern.matcher(mDesc);
            if(part.equals("")) {
                String subStr = (matcher.find()) ? matcher.group() : "";
                CharSequence sequence = Html.fromHtml(subStr);
                SpannableStringBuilder strBuilder = new SpannableStringBuilder(sequence);
                URLSpan[] urls = strBuilder.getSpans(0, sequence.length(), URLSpan.class);
                for (URLSpan span : urls) {
                    int start = strBuilder.getSpanStart(span);
                    int end = strBuilder.getSpanEnd(span);
                    int flags = strBuilder.getSpanFlags(span);
                    ClickableSpan clickable = new ClickableSpan() {
                        public void onClick(@NotNull View view) {
                            Intent browserIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(span.getURL()));
                            getContext().startActivity(browserIntent);
                        }
                        @Override
                        public void updateDrawState(@NonNull TextPaint ds) {
                            super.updateDrawState(ds);
                            ds.setColor(color);
                            ds.setUnderlineText(false);
                        }
                    };
                    strBuilder.setSpan(clickable, start, end, flags);
                    strBuilder.removeSpan(span);
                }
                mDescriptions[i] = new SpannableString(strBuilder);
                mDesc=mDesc.replaceFirst(pattern.toString(), strBuilder.toString());
                i++;
            } else {
                mDescriptions[i] = new SpannableString(part);
                i++;
            }
        }
        return plus(mDescriptions);
    }

    private SpannableString setUnderlineText(CharSequence mChar, Pattern pattern) {
        CharSequence subString = mChar;
        SpannableString ss = new SpannableString(subString);
        UnderlineSpan underlineSpan = new UnderlineSpan();
        Matcher matcher = pattern.matcher(subString);
        while (matcher.find()) {
            String changeText = matcher.group().replaceAll("<blockquote>","").replaceAll("</blockquote>","");
            subString = matcher.replaceFirst(changeText);
            ss = new SpannableString(subString);
            ss.setSpan(underlineSpan, subString.toString().indexOf(changeText),subString.toString().indexOf(changeText) + changeText.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        return ss;
    }

    private SpannableString setStrikeText (CharSequence mChar, Pattern pattern) {
        CharSequence subString = mChar;
        SpannableString ss = new SpannableString(subString);
        StrikethroughSpan strikethroughSpan = new StrikethroughSpan();
        Matcher matcher = pattern.matcher(subString);
        while (matcher.find()) {
            String changeText = matcher.group().replaceAll("<del>","<s>").replaceAll("</del>","</s>");
            subString = matcher.replaceFirst(changeText);
            ss = new SpannableString(subString);
            ss.setSpan(strikethroughSpan, subString.toString().indexOf(changeText),subString.toString().indexOf(changeText) + changeText.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        return ss;
    }

    private String setDash (String description, Pattern pattern) {
        String s = description;
        Matcher matcher = pattern.matcher(s);
        while (matcher.find()) {
            String changeText = matcher.group().replaceAll("<li>","- ").replaceAll("</li>","");
            s = matcher.replaceFirst(changeText);
        }
        return s;
    }

    private SpannableString setBoldStyle (CharSequence mChar, Pattern pattern) {
        CharSequence subString = mChar;
        SpannableString ss = new SpannableString(subString);
        StyleSpan boldSpan = new StyleSpan(Typeface.BOLD);
        Matcher matcher = pattern.matcher(subString);
        while (matcher.find()) {
            String changeText = matcher.group().replaceAll("<h\\d>","").replaceAll("</h\\d>","");
            subString = matcher.replaceFirst(changeText);
            ss = new SpannableString(subString);
            ss.setSpan(boldSpan, subString.toString().indexOf(changeText),subString.toString().indexOf(changeText) + changeText.length(),Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        return ss;
    }



    //Поменять
    private String deleteImages (String description, Pattern pattern) {
        Matcher matcher = pattern.matcher(description);
        return (matcher.find()) ? matcher.replaceAll("") : description;
    }

    private String deleteAll (String description, Pattern pattern) {
        Matcher matcher = pattern.matcher(description);
        return (matcher.find()) ? matcher.replaceAll("") : description;
    }

    private String setQuotes (String description, Pattern pattern) {
        Matcher matcher = pattern.matcher(description);
        return (matcher.find()) ? matcher.replaceAll("\"") : description;
    }

    private String setNewLine (String description, Pattern pattern) {
        Matcher matcher = pattern.matcher(description);
        return (matcher.find()) ? matcher.replaceAll("\n") : description;
    }

    //Пригодится
    @NonNull
    public CharSequence plus (@NonNull SpannableString one, @NonNull SpannableString two) {
        return TextUtils.concat(one,two);
    }

    @NonNull
    public CharSequence plus (@NonNull SpannableString one, @NonNull String two) {
        return TextUtils.concat(one,two);
    }

    @NonNull
    public CharSequence plus (@NonNull SpannableString[] spannableStrings) {
        return TextUtils.concat(spannableStrings);
    }
